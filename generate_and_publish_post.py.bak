import boto3
import json
import os
import re
import base64
import random
import tempfile
from wordpress_xmlrpc import Client, WordPressPost
from wordpress_xmlrpc.methods import posts, media
from wordpress_xmlrpc.methods.posts import NewPost
from wordpress_xmlrpc.compat import xmlrpc_client
import requests

# Constants
AWS_REGION = "us-west-2"  # Explicitly set to us-west-2
MODEL_ID = "anthropic.claude-3-sonnet-20240229-v1:0"  # Using Claude 3 Sonnet model

def get_wp_credentials():
    """Load WordPress credentials from JSON file"""
    try:
        with open('blog-credentials.json', 'r') as f:
            return json.load(f)
    except Exception as e:
        print(f"Error loading credentials: {e}")
        return None

def get_github_activity(username):
    """Get GitHub activity for a user"""
    headers = {'Accept': 'application/vnd.github.v3+json'}
    
    # Get starred repositories
    starred_url = f'https://api.github.com/users/{username}/starred'
    starred_response = requests.get(starred_url, headers=headers)
    starred_repos = []
    if starred_response.status_code == 200:
        starred_repos = [{'name': repo['name'], 'description': repo.get('description', 'No description')} 
                        for repo in starred_response.json()[:5]]
    
    # Get user's recent commits
    events_url = f'https://api.github.com/users/{username}/events'
    events_response = requests.get(events_url, headers=headers)
    recent_commits = []
    if events_response.status_code == 200:
        for event in events_response.json():
            if event['type'] == 'PushEvent':
                for commit in event['payload']['commits']:
                    recent_commits.append({
                        'repo': event['repo']['name'],
                        'message': commit['message']
                    })
                if len(recent_commits) >= 5:
                    break
    
    return {
        'starred_repos': starred_repos,
        'recent_commits': recent_commits
    }

def generate_post_with_bedrock(github_activity):
    """Generate a new SEO-optimized post using Amazon Bedrock's Claude 3 Sonnet model"""
    try:
        bedrock_runtime = boto3.client(
            service_name="bedrock-runtime",
            region_name=AWS_REGION
        )
        
        # Format GitHub activity for the prompt
        starred_repos = "\n".join([f"- {repo['name']}: {repo['description']}" 
                                for repo in github_activity['starred_repos']])
        recent_commits = "\n".join([f"- In {commit['repo']}: {commit['message']}" 
                                for commit in github_activity['recent_commits']])
        
        prompt = f"""
You are a witty, sarcastic tech blogger writing about Kubernetes.

Write a blog post with the following characteristics:
1. Sarcastic, humorous tone
2. Personal anecdote related to tech (mention one of these GitHub repos: {starred_repos})
3. Discussion of Kubernetes frustrations and challenges
4. An "aha moment" or lesson learned
5. Practical advice with a sarcastic twist
6. A call-to-action for reader engagement
7. Include ONE image placeholder using format [IMAGE: description]
8. Use H2 and H3 subheadings for structure
9. 800-1000 words total

Return ONLY a JSON object with these fields:
{{
  "title": "Your catchy title here (under 60 chars)",
  "focus_keyphrase": "kubernetes humor",
  "meta_description": "Brief description under 160 chars",
  "content": "Your HTML formatted post content here",
  "tags": ["kubernetes", "devops", "humor", "tech"]
}}

No explanations or additional text outside the JSON object.
"""

        # Prepare the request for Claude 3 Sonnet
        body = json.dumps({
            "anthropic_version": "bedrock-2023-05-31",
            "max_tokens": 4096,
            "temperature": 0.7,
            "messages": [
                {
                    "role": "user",
                    "content": prompt
                }
            ]
        })

        # Invoke Bedrock with Claude 3 Sonnet
        response = bedrock_runtime.invoke_model(
            modelId=MODEL_ID,
            body=body
        )
        
        response_body = json.loads(response.get('body').read())
        
        # Handle different response formats from Claude models
        if 'messages' in response_body:
            # Claude 3 format with messages array
            content = response_body.get('messages')[0].get('content')
        elif isinstance(response_body.get('content'), list):
            # Claude 3 format with content array
            content = response_body.get('content')[0].get('text', '')
        else:
            # Claude 2 format with string content
            content = response_body.get('content', '')
        
        # Create a fallback post if parsing fails
        fallback_post = {
            "title": "Adventures in Kubernetes: A Developer's Tale",
            "focus_keyphrase": "kubernetes development",
            "meta_description": "A humorous look at the challenges and triumphs of working with Kubernetes from a developer's perspective.",
            "content": f"""
<h2>When Kubernetes and I First Met</h2>
<p><div class='image-suggestion'><em>Suggested image here: A developer looking confused at a complex Kubernetes diagram on a whiteboard</em></div></p>
<p>So there I was, thinking I had this whole container thing figured out. Docker? Check. Microservices? Sure, why not. Then Kubernetes entered the chat, and suddenly I was drowning in a sea of pods, services, and deployments.</p>

<h3>The Learning Curve</h3>
<p>If Kubernetes were a roller coaster, it would be the kind that requires you to sign a waiver and question your life choices. The learning curve isn't just steep—it's practically vertical.</p>

<p>After weeks of YAML-induced nightmares and mysterious pod failures, I finally had my "aha" moment. Kubernetes isn't just about orchestrating containers; it's about embracing chaos and learning to dance with it.</p>

<h3>The Bigger Picture</h3>
<p>In the grand scheme of tech evolution, Kubernetes represents our industry's persistent belief that we can solve complexity with... more complexity. It's like fighting fire with a flamethrower—oddly effective but guaranteed to create new problems.</p>

<h3>Survival Tips</h3>
<p>For those brave souls venturing into the Kubernetes wilderness, remember: start small, embrace failure as a learning tool, and always have a rollback strategy. Oh, and keep a sense of humor—you'll need it when your carefully crafted deployment crashes at 2 AM for no apparent reason.</p>

<p>Have you battled the Kubernetes beast? Share your war stories in the comments below. Or better yet, tell me about your most spectacular Kubernetes failure—misery loves company, especially in DevOps!</p>
""",
            "tags": ["Kubernetes", "DevOps", "Containers", "Cloud Native", "Microservices", "Tech Humor"]
        }
        
        # Try to parse the response, use fallback if it fails
        try:
            # Print the raw response for debugging
            print("\nRaw response from Claude (full response):")
            print(content)
            print("\n" + "-"*50 + "\n")
            
            # Clean and prepare the content for parsing
            # Remove any text before the first { and after the last }
            content = content.strip()
            start_idx = content.find('{')
            end_idx = content.rfind('}')
            if start_idx != -1 and end_idx != -1:
                content = content[start_idx:end_idx + 1]
            
            # Remove code block markers and clean up the JSON
            content = re.sub(r'```json\s*|```\s*', '', content)
            
            # Fix escaping issues
            content = content.replace('\\"', '"')  # Fix double escaped quotes
            content = re.sub(r'(?<!\\)\\n', '\n', content)  # Handle newlines
            content = content.replace('\\\\', '\\')  # Fix double escaped backslashes
            
            # Fix WordPress block formatting that causes JSON parsing issues
            content = content.replace('<!-- wp:', '<!-- wp-')
            content = content.replace('/wp:paragraph -->', '/wp-paragraph -->')
            content = content.replace('/wp:heading -->', '/wp-heading -->')
            content = content.replace('/wp:list -->', '/wp-list -->')
            content = content.replace('/wp:image -->', '/wp-image -->')
            
            # Fix line breaks in the content field
            content = re.sub(r'("content":\s*".*?)[\r\n]+\s*(.*?"(?=,\s*"tags"|}))', r'\1 \2', content, flags=re.DOTALL)
            
            # Handle HTML entities
            content = content.replace('&quot;', '"')
            content = content.replace('&apos;', "'")
            
            # Try to parse the cleaned JSON
            try:
                post_data = json.loads(content)
                print("Successfully parsed JSON response")
            except json.JSONDecodeError as e:
                print(f"Failed to parse JSON after cleaning: {e}")
                
                # Try manual extraction as a last resort
                try:
                    print("Attempting manual field extraction...")
                    title_match = re.search(r'"title":\s*"([^"]+)"', content)
                    keyphrase_match = re.search(r'"focus_keyphrase":\s*"([^"]+)"', content)
                    meta_match = re.search(r'"meta_description":\s*"([^"]+)"', content)
                    content_match = re.search(r'"content":\s*"(.*?)"(?=,\s*"tags"|$)', content, re.DOTALL)
                    tags_match = re.search(r'"tags":\s*\[(.*?)\]', content, re.DOTALL)
                    
                    if title_match and content_match:
                        post_data = {
                            "title": title_match.group(1),
                            "focus_keyphrase": keyphrase_match.group(1) if keyphrase_match else "kubernetes",
                            "meta_description": meta_match.group(1) if meta_match else "A blog post about Kubernetes",
                            "content": content_match.group(1).replace('\\n', '\n').replace('\\"', '"'),
                            "tags": [tag.strip(' "') for tag in tags_match.group(1).split(',')] if tags_match else ["kubernetes", "devops", "tech-humor"]
                        }
                        print("Successfully extracted fields manually")
                    else:
                        raise ValueError("Could not extract all required fields")
                except Exception as e2:
                    print(f"Manual extraction failed: {e2}")
                    print("Using fallback post data")
                    post_data = fallback_post
            
            # Process image placeholders
            if "content" in post_data:
                # Remove DOCTYPE and HTML tags if present
                post_data["content"] = re.sub(r'<!DOCTYPE html><html><head></head><body>|</body></html>', '', post_data["content"])
                
                # Remove any leading/trailing whitespace
                post_data["content"] = post_data["content"].strip()
            
            return post_data
        except json.JSONDecodeError as e:
            print(f"Error parsing JSON response: {e}")
            return None
            
    except Exception as e:
        print(f"Error generating post: {e}")
        return None

def generate_image_with_bedrock(description):
    """Generate an image using Amazon Bedrock's Titan Image Generator"""
    try:
        print(f"Starting image generation for: {description}")
        bedrock_runtime = boto3.client(
            service_name="bedrock-runtime",
            region_name=AWS_REGION
        )
        
        # Clean up the description if it ends with .jpg or other file extensions
        if description.endswith('.jpg') or description.endswith('.png'):
            description = description.rsplit('.', 1)[0]
        
        # Handle hyphenated descriptions by replacing with spaces
        description = description.replace('-', ' ')
        
        # Make the prompt more generic to avoid content filter issues
        safe_description = f"A simple cartoon illustration of {description}"
        
        # Prepare the request for Titan Image Generator
        request_body = {
            "taskType": "TEXT_IMAGE",
            "textToImageParams": {
                "text": safe_description,
                "negativeText": "blurry, distorted, low quality, nsfw, offensive"
            },
            "imageGenerationConfig": {
                "numberOfImages": 1,
                "height": 512,
                "width": 512,
                "cfgScale": 8.0,
                "seed": random.randint(0, 4294967295)
            }
        }
        
        print(f"Calling Bedrock with request: {json.dumps(request_body)}")
        
        # Call Bedrock's Titan Image Generator
        response = bedrock_runtime.invoke_model(
            modelId="amazon.titan-image-generator-v1",
            body=json.dumps(request_body)
        )
        
        # Process the response
        response_body = json.loads(response['body'].read())
        print(f"Got response with keys: {list(response_body.keys())}")
        
        if 'images' in response_body and len(response_body['images']) > 0:
            print(f"Found {len(response_body['images'])} images")
            image_data = base64.b64decode(response_body['images'][0])
            
            # Save to a temporary file
            temp_image = tempfile.NamedTemporaryFile(suffix='.png', delete=False)
            temp_image.write(image_data)
            temp_image.close()
            print(f"Image saved to temporary file: {temp_image.name}")
            return temp_image.name
        else:
            print("No images found in response")
            return None
    except Exception as e:
        print(f"Error generating image: {str(e)}")
        import traceback
        traceback.print_exc()
        return None

def publish_to_wordpress(post_data):
    """Publish the generated post to WordPress"""
    try:
        # Get WordPress credentials
        credentials = get_wp_credentials()
        if not credentials:
            return False
            
        # Create WordPress client
        wp = Client(
            credentials['xmlrpc_url'],
            credentials['username'],
            credentials['password']
        )
        
        # Create new post
        post = WordPressPost()
        post.title = post_data['title']
        post.content = post_data['content']  # Content already has images
        post.post_status = 'publish'
        post.terms_names = {
            'post_tag': ['kubernetes', 'devops', 'tech-humor'],
            'category': ['Tech Humor', 'DevOps']
        }
        
        # Set SEO metadata
        post.custom_fields = []
        post.custom_fields.append({
            'key': '_yoast_wpseo_focuskw',
            'value': post_data['focus_keyphrase']
        })
        post.custom_fields.append({
            'key': '_yoast_wpseo_metadesc',
            'value': post_data['meta_description']
        })
        
        # Publish the post
        post_id = wp.call(NewPost(post))
        print(f"Successfully published post with ID: {post_id}")
        return True
        
    except Exception as e:
        print(f"Error publishing to WordPress: {e}")
        return False
        
    except Exception as e:
        print(f"Error publishing to WordPress: {e}")
        return False
        
    except Exception as e:
        print(f"Error publishing to WordPress: {e}")
        return False

def process_images_in_content(content):
    """Process all image placeholders in the content and replace them with actual images"""
    # Get WordPress credentials for media upload
    credentials = get_wp_credentials()
    if not credentials:
        print("Failed to get WordPress credentials")
        return content
        
    # Create WordPress client
    wp = Client(
        credentials['xmlrpc_url'],
        credentials['username'],
        credentials['password']
    )
    
    # First, collect all placeholders with different patterns
    image_patterns = [
        r"\[IMAGE: (.*?)\]",
        r"\[Image: (.*?)\]",
        r"\[image: (.*?)\]"
    ]
    
    # Store all placeholders with their positions
    placeholders = []
    
    for pattern in image_patterns:
        for match in re.finditer(pattern, content):
            placeholders.append({
                'full_match': match.group(0),
                'description': match.group(1),
                'start': match.start(),
                'end': match.end()
            })
    
    print(f"Found {len(placeholders)} total image placeholders")
    
    # Sort placeholders by position (to replace from end to beginning)
    # This prevents position shifts when replacing text
    placeholders.sort(key=lambda x: x['start'], reverse=True)
    
    # Process each placeholder
    for placeholder in placeholders:
        description = placeholder['description']
        full_match = placeholder['full_match']
        
        print(f"Processing image placeholder: '{full_match}'")
        
        # Generate image using Bedrock
        image_path = generate_image_with_bedrock(description)
        
        if image_path:
            print(f"Image generated successfully at {image_path}")
            try:
                # Upload image to WordPress
                with open(image_path, 'rb') as img:
                    data = {
                        'name': f'ai-generated-{random.randint(1000, 9999)}.png',
                        'type': 'image/png',
                        'bits': xmlrpc_client.Binary(img.read()),
                        'caption': description
                    }
                
                # Upload to WordPress
                print(f"Uploading image for '{description}' to WordPress...")
                response = wp.call(media.UploadFile(data))
                img_url = response['url']
                print(f"Image uploaded successfully, URL: {img_url}")
                
                # Replace placeholder with actual image HTML
                image_html = f'<figure class="wp-block-image"><img src="{img_url}" alt="{description}"/><figcaption>{description}</figcaption></figure>'
                
                # Replace by slicing the content string at exact positions
                content = content[:placeholder['start']] + image_html + content[placeholder['end']:]
                print(f"Replaced placeholder at position {placeholder['start']}-{placeholder['end']}")
                
                # Clean up temporary file
                os.unlink(image_path)
            except Exception as e:
                print(f"Error uploading image to WordPress: {e}")
                # Replace with a text note since upload failed
                content = content[:placeholder['start']] + f'<p><em>Image description: {description}</em></p>' + content[placeholder['end']:]
        else:
            print(f"Failed to generate image for '{description}', using placeholder text instead")
            # Replace with a text note since image generation failed
            content = content[:placeholder['start']] + f'<p><em>Image description: {description}</em></p>' + content[placeholder['end']:]
    
    return content



def main():
    # Get GitHub activity
    github_username = "felipedbene"
    github_activity = get_github_activity(github_username)
    
    # Generate the post
    post_data = generate_post_with_bedrock(github_activity)
    
    if post_data:
        print("\nGenerated Blog Post:")
        print("===================")
        print(f"Title: {post_data.get('title', 'No title')}")
        print(f"Focus Keyphrase: {post_data.get('focus_keyphrase', 'No keyphrase')}")
        print(f"Meta Description: {post_data.get('meta_description', 'No description')}")
        print("\nContent Preview (first 500 chars):")
        print(f"{post_data.get('content', 'No content')[:500]}...")
        
                # Process content and generate images before publishing
        content = post_data['content']
        
        # Process all image placeholders and replace with actual images
        content = process_images_in_content(content)
        
        # Update the post content with images
        post_data['content'] = content
        
        # Now publish the post with all images already included
        if publish_to_wordpress(post_data):
            print("\nSuccessfully published to WordPress!")
        else:
            print("\nFailed to publish to WordPress")
    else:
        print("Failed to generate blog post")

if __name__ == "__main__":
    main()